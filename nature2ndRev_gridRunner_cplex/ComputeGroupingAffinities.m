function Affinity = ComputeGroupingAffinities (Primitives)

%% This function computes the Affinity matrix quantifying the saliency
%% between each edge SEGMENT pair. Different researchers have used
%% different mathematical forms this quantification. We use one particular
%% form that is a function of the angle between the segments, overlap,
%% distance, and length of the segments. Other forms are also possible. The
%% affinity matrix is a symmetric matrix. This function's argument is a
%% list structure containing all the primitives, which is generated by the
%% ReadAttsFile function. The primitives appear sorted with respect to
%% their lengths, in descending order.
%%
%% Copyright (c) 2011,  Sudeep Sarkar
%% All rights reserved
%%     This program is free software for research and educational purposes
%%     ONLY. For these purposes, you can redistribute it and/or modify it
%%     under the terms of the GNU General Public License as published by
%%     the Free Software Foundation, either version 3 of the License, or
%%     (at your option) any later version. This program is distributed in
%%     the hope that it will be useful, but WITHOUT ANY WARRANTY; without
%%     even the implied warranty of MERCHANTABILITY or FITNESS FOR A
%%     PARTICULAR PURPOSE.  See the GNU General Public License for more
%%     details. You should have received a copy of the GNU General Public
%%     License along with this program.  If not, see
%%     <http://www.gnu.org/licenses/>.

N_prim = size (Primitives, 2);
Dist = zeros (N_prim, N_prim);

%% Affinity based on length and parallelism concepts
% for (ii=1:N_prim)
%     %Affinity(ii,ii) = Primitives(ii).length;
%     for (jj=ii+1:N_prim)
%         if (Primitives(jj).length > Primitives(ii).length) i = jj; j = ii;
%         else i = ii; j = jj; end;
% 
%         theta = atan2 (Primitives(i).ey - Primitives(i).sy, ...
%             Primitives(i).ex - Primitives(i).sx);
%         [xei yei] = rotate_axis(Primitives(i).ex - Primitives(i).sx,...
%             Primitives(i).ey - Primitives(i).sy, theta);
%         [xsj, ysj] = rotate_axis(Primitives(j).sx - Primitives(i).sx,...
%             Primitives(j).sy - Primitives(i).sy, theta);
%         [xej, yej] = rotate_axis(Primitives(j).ex - Primitives(i).sx,...
%             Primitives(j).ey - Primitives(i).sy, theta);
% 
%         min_d = min([abs(ysj), abs(yej)])/xei;
%         max_d = max([abs(ysj), abs(yej)])/xei;
%         overlap = (min([xei, max([xsj, xej])]) - max([0, min([xsj, xej])]))/xei;
%         del_theta = atan2 (abs(ysj-yej), abs(xsj-xej));
%         Affinity(i, j) = (sqrt(Primitives(j).length*Primitives(i).length)*...
%             exp(-min_d)*exp(overlap-1)*cos(2*del_theta)*cos(2*del_theta));
%         Affinity(j, i) = Affinity(i, j);
%     end;
% end;

%% Affinity based on proximity, continuity, parallelism. It can handle
%% line-line, line-curve, and curve-curve configurations. It is based on
%% Quantitative Measures of Change Based on Feature Organization:
%% Eigenvalues and Eigenvectors,COMPUTER VISION AND IMAGE UNDERSTANDING
%% Vol. 71, No. 1, July, pp. 110-136, 1998.

for (ii=1:N_prim)
    for (jj=ii+1:N_prim)
        if (Primitives(jj).length > Primitives(ii).length) i = jj; j = ii;
        else i = ii; j = jj; end;

        Li = Primitives(i).length;
        Lj = Primitives(j).length;

        %Significance of each segment is proportional to their lengths.
        %Primitives(1) is the longest primitive in the list.
        Si = Li; %sqrt(Li/(Primitives(1).length+Primitives(i).error));
        Sj = Lj; %sqrt(Lj/(Primitives(1).length+Primitives(j).error));
        
        % Compute the PROXIMITY factor
        X = [Primitives(i).sx; Primitives(i).ex; Primitives(j).sx; Primitives(j).ex];
        Y = [Primitives(i).sy; Primitives(i).ey; Primitives(j).sy; Primitives(j).ey];
        D = pdist([X Y]);
        % if we number the start-end pts of segment i as 1 and 2,
        % respectively, and the start-end pts of segment j as 3 and 4,
        % respectively, then d is a vector with [d12, d13, d14, d15, d23,
        % d24, d25, d34]
        Proximity = 1 - min(1, min(D)/min(Li, Lj));

        %Compute SYMMETRY factor, warp the smaller segment onto the larger
        %one with the (nearest) end points mapped into one another.
        P = [Primitives(i).x', Primitives(i).y'];
        Q = [Primitives(j).x', Primitives(j).y'];
        if ((D(2) > D(3)) || (D(5) > D(4))) % D13 > D14 or D24 > D23, then flip the order of one of the segments
            Q = flipud(Q);
        end;
        wf = floor(Li/Lj);
        Sxy = (P(1:wf:Lj*wf,:) + Q)./2; % symmetry axis pts.
        Sw = sqrt(sum(((P(1:wf:Lj*wf,:) - Q).^2)')); % symmetry axis width
        Lsym = length(Sw);
        
        % fit a straight line to the axis width function and compute its
        % error. Ideally the width should be a contant or linear changing
        % for skew symmetry
        if (Lsym > 5)
            p = polyfit([1:Lsym], Sw, 1);
            q = polyval(p,[1:Lsym]);
            Lerr = norm(Sw - q);
        else
            Lerr = 0;
        end
        Symmetry = min([Lsym/(Lsym + min(Li, Lj)), Lsym/(Lsym + Lerr)]);
        
       
        %Continuity factor
        
        Slope = [];
        if (strcmp(Primitives(i).mark, 'ARC') == 1)
            Slope = [Slope; 
                     -Primitives(i).sy + Primitives(i).yc, -Primitives(i).xc + Primitives(i).sx;
                     Primitives(i).ey - Primitives(i).yc, Primitives(i).xc - Primitives(i).ex];

        else
            Slope = [Slope; Primitives(i).sx - Primitives(i).ex, Primitives(i).sy - Primitives(i).ey;
                            Primitives(i).ex - Primitives(i).sx, Primitives(i).ey - Primitives(i).sy];
        end
        if (strcmp(Primitives(j).mark, 'ARC') == 1)
            Slope = [Slope; -Primitives(j).sy + Primitives(j).yc, -Primitives(j).xc + Primitives(j).sx;
                             Primitives(j).ey - Primitives(j).yc, Primitives(j).xc - Primitives(j).ex];
        else
            Slope = [Slope; Primitives(j).sx - Primitives(j).ex, Primitives(j).sy - Primitives(j).ey;
                            Primitives(j).ex - Primitives(j).sx, Primitives(j).ey - Primitives(j).sy];
        end
        Slope = Slope./(sqrt(sum(Slope'.^2)')*ones(1, 2));
        DotP = Slope*Slope';
        DotP = [DotP(1,2); DotP(1,3); DotP(1,4); DotP(2,3); DotP(2,4); DotP(3,4)];
        [min_d index] = min(D(2:5));  
        CFactor = DotP(index+1)^2*(DotP(index+1) < 0);
        Continuity = min([(Li+Lj)/(Li+Lj+min_d), CFactor]);
        
         %Compute PERPENDICULARITY factor, 
        PFactor = 1 - DotP(index+1)^2;
        Perp = min([(Li+Lj)/(Li+Lj+min_d), PFactor]);
   
        
        Affinity(i, j) = sqrt(Si*Sj)*Proximity*(Symmetry+Continuity+Perp);

%         if (Affinity(i, j) > 1.0)
%             fprintf(1, '\n Sig(i)=%f, Sig(j)=%f, Proximity=%f, Symmetry=%f, Continuity=%f, Perp=%f, A=%f', Si, Sj, Proximity, Symmetry, Continuity, Perp, Affinity(i,j));
%             subplot(2,2,1);
%             plot(P(:,1), P(:,2)); hold on;  plot(Q(:,1), Q(:,2));  plot(Sxy(:,1), Sxy(:,2),'r');
% 
%             subplot(2,2,2); plot(Sw); hold on; plot (q, 'r'); hold off;
%             subplot(2,2,1); hold on; quiver (X, Y, Slope(:,1), Slope(:,2), 0.3, 'r'); hold off;
%             pause (.1);
%         end;
        Affinity(j, i) = Affinity (i, j);
    end;
end;

%% Affinity based on distance from convex hull of each and length of the
%% sides of the convex hull over the two segments.
% for (i=1:N_prim)
%     for (j=i+1:N_prim)
%         %         [CHull Area1] = convhull(Primitives(i).x', Primitives(i).y');
%         %         [CHull Area2] = convhull(Primitives(j).x', Primitives(j).y');
% 
%         Ni = Primitives(i).length; Nj = Primitives(j).length;
%         X = [Primitives(i).x(1:2:Ni) Primitives(j).x(1:2:Nj)
%             Primitives(i).y(1:2:Ni) Primitives(j).y(1:2:Nj)];
% 
%         N = size(X, 2);
% 
%         [CHull Area] = convhull(X(1,:)', X(2,:)');
%         Nc = length(CHull); % number of points on the Hull.
% 
%         % Distance of a point (x0, y0) to a convex hull edge joining (x1,
%         % y1) and (x2, y2) needs the solutions for L1 and L2 in the
%         % following equation
%         %
%         % (x2 - x1) L1 - (y2 - y1)L2 = x0 - x1;
%         % (y2 - y1) L1 + (x2 - x1)L2 = y0 - y1;
%         %
%         % L1 should be between 0 and 1 for the perpendicular from (x0, y0)
%         % to the line segment to fall on the line segment.
%         % abs(L2)*||y2 - y1, x1-x2|| is the perpendicular distance to the line segment,
%         % Below we have converted all the distance computations of the
%         % point on the contour to the convex hull in a matrix format.
% 
%         XC = X(:, CHull); % all the points on the convex hull, in first row are the X coords, in the second row are the Y coords.
%         A = XC(:,[2:Nc,1]) - XC; %difference of consecutive coordinates on the convex hull -- forms an array of coefficients for L1 (see equation above)
%         A = A(:,1:Nc-1); % since the last point is repeated in the convex hull, the last column of A is zero.
%         AA(:, 1:2:2*(Nc-1)) = A;
%         D = sqrt(A(1,:).^2 + A(2,:).^2); % normalizing term used so that L2 end up being the distance to the line.
%         AA(:, 2:2:2*(Nc-1)) = [-A(2,:)./D; A(1,:)./D]; %-- inserts the array of coefficients for L2 (see equation above)
% 
% 
%         Ainv = []; B = [];
%         for k=0:Nc-2
%             Ainv = blkdiag(Ainv, [AA(2, 2*k+2)  -AA(1, 2*k+2);
%                 -AA(2, 2*k+1)   AA(1, 2*k+1)]./D(k+1)); % use the form for the inversion of a 2x2 matrix instead of a call to inv
%             B = [B; [X - XC(:,k+1)*ones(1, N) ]];
%         end;
%         M = size(B, 1);
%         d = 9999.0 * ones(M/2,N);
%         L = Ainv*B;
%         L1 = L(1:2:M,:);
%         valid = find((L1 >= 0).*(L1 <= 1.0)); % valid distances are those for which the perpendicular falls inside the line segment, 0 <= L1 <= 1
%         L2 = L(2:2:M,:); % extact just the distance rows
%         d(valid) = abs(L2(valid));
%         d = min(d);
%         Affinity(i, j) = sqrt(Ni*Nj)*exp(-mean(d)/10 - max(D)/(Ni+Nj)); % 5 pixel deviation tolerated
% 
%         %d = 9999999.0 * ones(1, N); % array to store the mininum distance of each point to the convex hull.
%         % This piece of code was used to verify that the distances to the
%         % convex hull was being computed correctly.
%         %                 for k=0:Nc-2 % iterate over each side of the convex hull to compute minimum distances of each point in the original pair of curves to the hull.
%         %                     A = AA(:, 2*k+1:2*k+2); % extract the 2 by 2 matrix of coefficients for L1 and L2 for each side of the convex hull
%         %                     B = X' - XC(:,k+1)*ones(1, N) ; % the right hand side of the equation involving L1 and L2 for all the curve points.
%         %                     L = inv(A)*B; % computes L1 and L2 for each of the curve points.
%         %                     valid = find((L(1,:) >= 0).*(L(1,:) <= 1.0)); % valid distances are those for which the perpendicular falls inside the line segment, 0 <= L1 <= 1
%         %                     d(valid) = min(d(valid), abs(L(2,valid)));
%         %
%         %                     %             subplot(2,2,4);
%         %                     %             plot(Primitives(i).x, Primitives(i).y, 'm');hold on;
%         %                     %             plot(Primitives(j).x, Primitives(j).y);
%         %                     %             plot([XC(1,k+1), XC(1,k+2)], [XC(2,k+1), XC(2,k+2)], 'r');
%         %                     %
%         %                     %             for kk=1:length(valid)
%         %                     %                 Xp = X(valid(kk),:)' - L(2,valid(kk))*A(:,2);
%         %                     %                 plot([Xp(1), X(valid(kk), 1)], [Xp(2), X(valid(kk),2)], 'g');
%         %                     %             end
%         %
%         %                 end;
% %         if (Affinity(i, j) > 0)
% %             subplot(2, 2, 1); plot(Primitives(i).x, Primitives(i).y, 'm'); hold on;
% %             subplot(2, 2, 1); plot(Primitives(j).x, Primitives(j).y);
% %             plot(X(1,CHull), X(2,CHull), 'g');
% %             hold off;
% %             subplot(2,2,2); plot(d);
% %             subplot(2,2,3); hist(d);
% %             subplot(2,2,4); plot(D);
% %             fprintf(1, '\n (%d %d), Affinity = %f,', i, j,  Affinity(i, j));
% %             pause(0.1);
% %         end;
%         Affinity(j, i) = Affinity(i, j);
%     end;
% end;
% 
%        
%        %         %         if (strcmp(Primitives(i).mark, 'LINE') & strcmp(Primitives(j).mark, 'LINE'))
% %                     P = [Primitives(i).ex Primitives(i).ey
% %                         Primitives(i).sx Primitives(i).sy];
% %                     Q = [Primitives(j).ex Primitives(j).ey
% %                         Primitives(j).sx Primitives(j).sy];
% %                     TFORM1 = cp2tform(P, Q, 'nonreflective similarity');
% %                     % Next estimate transformation by exchanging the start and end
% %                     % points
% %                     TFORM2 = cp2tform(P, [Q(2,:); Q(1,:)], 'nonreflective similarity');
% %                     d1 = (sum(log(eig(TFORM1.tdata.T'*TFORM1.tdata.T)).^2));
% %                     d2 = (sum(log(eig(TFORM2.tdata.T'*TFORM2.tdata.T)).^2));
% %                     Affinity(i, j) = exp(-(min (d1, d2)/max(Primitives(jj).length, Primitives(ii).length) + 0.1));
% %                 end;
%         %     end;
%         % end;
%         %         if (strcmp(Primitives(i).mark, 'LINE') &
%         %         strcmp(Primitives(j).mark, 'LINE'))
%         
%         %         end;
%         
%         
%        %Affinity(i, j) = (sqrt(Primitives(j).length*Primitives(i).length)*...
%         %   exp(-min_d)*exp(2*(overlap-1))*exp(-(del_theta)^2));
%        
%        %Affinity(i, j) = (sqrt(Primitives(j).length*Primitives(i).length)*...
%         %   exp(-(del_theta)));
%        
%         %Affinity(i, j) = exp(-min_d)*exp(overlap-1)*cos(2*del_theta)*cos(2*del_theta);
%         
% %---------------------------------------------------------------

% % Normalize affinity to be between 0 and 1
%% Linear normalization does not change the traditional spectral clustering
%% measure based grouping
% 
% maxA = max(max(Affinity));
% minA = min(min(Affinity));
% 
% if ((maxA > 1.0) || (minA < 0)) 
%     fprintf(1, '\n Values of the affinity matrix are beyond  0 to 1 range. [%f %f]', minA, maxA);
%     maxA = maxA + eps; minA = eps;
%     Affinity = (Affinity-minA)/(maxA - minA);
% end;

function [xo yo] = rotate_axis (x, y, theta)
R = [cos(theta)  sin(theta)
    -sin(theta)  cos(theta)];
p = [x; y];
q = R*p;
xo = q(1); yo = q(2);
%-----------------------------------------------------------------
 

        